<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI Fix Validation Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0A0A0A, #1A1A1A);
            color: #ffffff;
            min-height: 100vh;
        }

        .test-container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 212, 255, 0.2);
        }

        .test-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .test-header h1 {
            background: linear-gradient(135deg, #00D4FF, #FF6B6B);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 2.5rem;
            margin: 0;
        }

        .test-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .test-name {
            flex: 1;
            font-weight: 500;
        }

        .test-status {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            min-width: 80px;
            text-align: center;
        }

        .status-pass {
            background: rgba(40, 167, 69, 0.2);
            color: #28A745;
            border: 1px solid #28A745;
        }

        .status-fail {
            background: rgba(220, 53, 69, 0.2);
            color: #DC3545;
            border: 1px solid #DC3545;
        }

        .status-warning {
            background: rgba(255, 193, 7, 0.2);
            color: #FFC107;
            border: 1px solid #FFC107;
        }

        .run-button {
            background: linear-gradient(135deg, #00D4FF, #FF6B6B);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin: 20px auto;
            display: block;
            transition: all 0.3s ease;
        }

        .run-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 212, 255, 0.3);
        }

        .scroll-test-area {
            height: 200px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }

        .scroll-content {
            height: 500px;
            background: linear-gradient(to bottom, 
                rgba(0, 212, 255, 0.1) 0%, 
                rgba(255, 107, 107, 0.1) 50%, 
                rgba(0, 212, 255, 0.1) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
        }

        .results-summary {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid #00D4FF;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1>🔧 UI Fix Validation</h1>
            <p>Testing scroll functionality, geometric theme consistency, and rendering performance</p>
        </div>

        <button class="run-button" onclick="runAllTests()">🚀 Run All Tests</button>

        <div class="results-summary" id="resultsSummary" style="display: none;">
            <h3>Test Results Summary</h3>
            <div class="summary-stats">
                <div class="stat-item">
                    <div class="stat-number" id="passCount" style="color: #28A745;">0</div>
                    <div class="stat-label">Passed</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="failCount" style="color: #DC3545;">0</div>
                    <div class="stat-label">Failed</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="warningCount" style="color: #FFC107;">0</div>
                    <div class="stat-label">Warnings</div>
                </div>
            </div>
        </div>

        <!-- Scroll Test -->
        <div class="test-item" data-test="scroll-functionality">
            <span class="test-name">Page Scroll Functionality</span>
            <span class="test-status" id="scrollStatus">Not Tested</span>
        </div>

        <div class="scroll-test-area" id="scrollTestArea">
            <div class="scroll-content">
                <div>
                    <h4>Scroll Test Area</h4>
                    <p>This area should be scrollable. Try scrolling up and down within this box.</p>
                    <p>If you can scroll here, the scroll fix is working correctly.</p>
                </div>
            </div>
        </div>

        <!-- CSS Loading Test -->
        <div class="test-item" data-test="css-loading">
            <span class="test-name">CSS Loading & Geometric Theme</span>
            <span class="test-status" id="cssStatus">Not Tested</span>
        </div>

        <!-- Overflow Test -->
        <div class="test-item" data-test="overflow-fix">
            <span class="test-name">Body Overflow Fix</span>
            <span class="test-status" id="overflowStatus">Not Tested</span>
        </div>

        <!-- Positioning Test -->
        <div class="test-item" data-test="positioning">
            <span class="test-name">Element Positioning</span>
            <span class="test-status" id="positioningStatus">Not Tested</span>
        </div>

        <!-- Performance Test -->
        <div class="test-item" data-test="performance">
            <span class="test-name">Rendering Performance</span>
            <span class="test-status" id="performanceStatus">Not Tested</span>
        </div>

        <!-- Responsive Test -->
        <div class="test-item" data-test="responsive">
            <span class="test-name">Responsive Behavior</span>
            <span class="test-status" id="responsiveStatus">Not Tested</span>
        </div>

        <!-- JavaScript Initialization Test -->
        <div class="test-item" data-test="js-init">
            <span class="test-name">JavaScript Initialization</span>
            <span class="test-status" id="jsInitStatus">Not Tested</span>
        </div>

        <!-- Console Errors Test -->
        <div class="test-item" data-test="console-errors">
            <span class="test-name">Console Errors</span>
            <span class="test-status" id="consoleStatus">Not Tested</span>
        </div>
    </div>

    <script>
        class UIFixValidator {
            constructor() {
                this.testResults = {};
                this.consoleErrors = [];
                this.setupConsoleMonitoring();
            }

            setupConsoleMonitoring() {
                const originalError = console.error;
                const originalWarn = console.warn;

                console.error = (...args) => {
                    this.consoleErrors.push({ type: 'error', message: args.join(' '), timestamp: Date.now() });
                    originalError.apply(console, args);
                };

                console.warn = (...args) => {
                    this.consoleErrors.push({ type: 'warning', message: args.join(' '), timestamp: Date.now() });
                    originalWarn.apply(console, args);
                };
            }

            async runAllTests() {
                console.log('🧪 Starting UI Fix Validation Tests...');
                
                const tests = [
                    'scroll-functionality',
                    'css-loading',
                    'overflow-fix',
                    'positioning',
                    'performance',
                    'responsive',
                    'js-init',
                    'console-errors'
                ];

                for (const test of tests) {
                    await this.runTest(test);
                    await this.delay(100);
                }

                this.displaySummary();
                console.log('✅ All tests completed');
            }

            async runTest(testName) {
                let result;
                
                switch (testName) {
                    case 'scroll-functionality':
                        result = this.testScrollFunctionality();
                        break;
                    case 'css-loading':
                        result = this.testCSSLoading();
                        break;
                    case 'overflow-fix':
                        result = this.testOverflowFix();
                        break;
                    case 'positioning':
                        result = this.testPositioning();
                        break;
                    case 'performance':
                        result = await this.testPerformance();
                        break;
                    case 'responsive':
                        result = this.testResponsive();
                        break;
                    case 'js-init':
                        result = this.testJSInitialization();
                        break;
                    case 'console-errors':
                        result = this.testConsoleErrors();
                        break;
                    default:
                        result = { status: 'fail', message: 'Unknown test' };
                }

                this.testResults[testName] = result;
                this.updateTestStatus(testName, result);
            }

            testScrollFunctionality() {
                const bodyOverflow = getComputedStyle(document.body).overflow;
                const htmlOverflow = getComputedStyle(document.documentElement).overflow;
                const bodyOverflowY = getComputedStyle(document.body).overflowY;
                
                const canScroll = bodyOverflow !== 'hidden' && htmlOverflow !== 'hidden';
                const hasVerticalScroll = bodyOverflowY === 'auto' || bodyOverflowY === 'scroll';
                
                if (canScroll && hasVerticalScroll) {
                    return { status: 'pass', message: 'Scroll functionality working' };
                } else {
                    return { status: 'fail', message: `Body overflow: ${bodyOverflow}, HTML overflow: ${htmlOverflow}` };
                }
            }

            testCSSLoading() {
                const rootStyles = getComputedStyle(document.documentElement);
                const primaryCyan = rootStyles.getPropertyValue('--primary-cyan').trim();
                const primaryPink = rootStyles.getPropertyValue('--primary-pink').trim();
                
                const hasGeometricColors = primaryCyan === '#00D4FF' && primaryPink === '#FF6B6B';
                
                // Check if geometric theme CSS is loaded
                const stylesheets = Array.from(document.styleSheets);
                const hasGeometricCSS = stylesheets.some(sheet => {
                    try {
                        return sheet.href && (sheet.href.includes('geometric') || sheet.href.includes('unified'));
                    } catch (e) {
                        return false;
                    }
                });

                if (hasGeometricColors && hasGeometricCSS) {
                    return { status: 'pass', message: 'Geometric theme loaded correctly' };
                } else if (hasGeometricColors) {
                    return { status: 'warning', message: 'Colors loaded but CSS files may be missing' };
                } else {
                    return { status: 'fail', message: 'Geometric theme not loaded' };
                }
            }

            testOverflowFix() {
                const bodyStyle = getComputedStyle(document.body);
                const htmlStyle = getComputedStyle(document.documentElement);
                
                const bodyOverflow = bodyStyle.overflow;
                const htmlOverflow = htmlStyle.overflow;
                const bodyOverflowX = bodyStyle.overflowX;
                
                const isFixed = bodyOverflow !== 'hidden' && htmlOverflow !== 'hidden' && bodyOverflowX === 'hidden';
                
                if (isFixed) {
                    return { status: 'pass', message: 'Overflow properly configured' };
                } else {
                    return { status: 'fail', message: `Body: ${bodyOverflow}, HTML: ${htmlOverflow}, X: ${bodyOverflowX}` };
                }
            }

            testPositioning() {
                // Check if elements have proper z-index and positioning
                const elements = [
                    { selector: '.control-panel', expectedZIndex: '100' },
                    { selector: '.user-status-bar', expectedZIndex: '100' },
                    { selector: '#play-pause-button', expectedZIndex: '100' }
                ];

                let issues = [];
                let found = 0;

                elements.forEach(({ selector, expectedZIndex }) => {
                    const element = document.querySelector(selector);
                    if (element) {
                        found++;
                        const zIndex = getComputedStyle(element).zIndex;
                        if (zIndex !== expectedZIndex && zIndex !== 'auto') {
                            issues.push(`${selector}: z-index ${zIndex} (expected ${expectedZIndex})`);
                        }
                    }
                });

                if (found === 0) {
                    return { status: 'warning', message: 'No UI elements found to test' };
                } else if (issues.length === 0) {
                    return { status: 'pass', message: `${found} elements positioned correctly` };
                } else {
                    return { status: 'fail', message: `Issues: ${issues.join(', ')}` };
                }
            }

            async testPerformance() {
                const startTime = performance.now();
                
                // Simulate some DOM operations
                for (let i = 0; i < 100; i++) {
                    const div = document.createElement('div');
                    div.style.transform = 'translateZ(0)';
                    document.body.appendChild(div);
                    document.body.removeChild(div);
                }
                
                const endTime = performance.now();
                const duration = endTime - startTime;
                
                // Check memory usage if available
                let memoryInfo = '';
                if (performance.memory) {
                    const usedMB = performance.memory.usedJSHeapSize / 1024 / 1024;
                    memoryInfo = ` Memory: ${usedMB.toFixed(2)}MB`;
                }
                
                if (duration < 50) {
                    return { status: 'pass', message: `Fast rendering: ${duration.toFixed(2)}ms${memoryInfo}` };
                } else if (duration < 100) {
                    return { status: 'warning', message: `Moderate performance: ${duration.toFixed(2)}ms${memoryInfo}` };
                } else {
                    return { status: 'fail', message: `Slow performance: ${duration.toFixed(2)}ms${memoryInfo}` };
                }
            }

            testResponsive() {
                const viewport = window.innerWidth;
                const isMobile = viewport <= 768;
                const isTablet = viewport <= 1024 && viewport > 768;
                
                // Check if body has responsive classes
                const hasResponsiveClasses = document.body.classList.contains('mobile-layout') ||
                                           document.body.classList.contains('tablet-layout') ||
                                           document.body.classList.contains('desktop-layout');
                
                const viewportMeta = document.querySelector('meta[name="viewport"]');
                const hasViewportMeta = viewportMeta !== null;
                
                if (hasViewportMeta && (hasResponsiveClasses || viewport > 1024)) {
                    return { status: 'pass', message: `Responsive for ${viewport}px viewport` };
                } else if (hasViewportMeta) {
                    return { status: 'warning', message: 'Viewport meta present but no responsive classes' };
                } else {
                    return { status: 'fail', message: 'Missing viewport meta tag' };
                }
            }

            testJSInitialization() {
                // Check if UI initialization fix is loaded
                const hasUIFix = typeof window.uiInitFix !== 'undefined';
                const hasDebugFunction = typeof window.debugUI === 'function';
                
                // Check if body has loaded class
                const hasLoadedClass = document.body.classList.contains('loaded');
                const hasLoadingClass = document.body.classList.contains('loading-state');
                
                if (hasUIFix && hasLoadedClass && !hasLoadingClass) {
                    return { status: 'pass', message: 'UI initialization completed successfully' };
                } else if (hasUIFix) {
                    return { status: 'warning', message: 'UI fix loaded but initialization may be incomplete' };
                } else {
                    return { status: 'fail', message: 'UI initialization fix not found' };
                }
            }

            testConsoleErrors() {
                const errorCount = this.consoleErrors.filter(e => e.type === 'error').length;
                const warningCount = this.consoleErrors.filter(e => e.type === 'warning').length;
                
                if (errorCount === 0 && warningCount === 0) {
                    return { status: 'pass', message: 'No console errors or warnings' };
                } else if (errorCount === 0) {
                    return { status: 'warning', message: `${warningCount} warnings found` };
                } else {
                    return { status: 'fail', message: `${errorCount} errors, ${warningCount} warnings` };
                }
            }

            updateTestStatus(testName, result) {
                const statusElement = document.getElementById(testName.replace('-', '') + 'Status');
                if (statusElement) {
                    statusElement.textContent = result.message;
                    statusElement.className = `test-status status-${result.status}`;
                }
            }

            displaySummary() {
                const results = Object.values(this.testResults);
                const passCount = results.filter(r => r.status === 'pass').length;
                const failCount = results.filter(r => r.status === 'fail').length;
                const warningCount = results.filter(r => r.status === 'warning').length;
                
                document.getElementById('passCount').textContent = passCount;
                document.getElementById('failCount').textContent = failCount;
                document.getElementById('warningCount').textContent = warningCount;
                document.getElementById('resultsSummary').style.display = 'block';
                
                console.log(`Test Summary: ${passCount} passed, ${failCount} failed, ${warningCount} warnings`);
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        const validator = new UIFixValidator();

        function runAllTests() {
            validator.runAllTests();
        }

        // Auto-run tests after page load
        window.addEventListener('load', () => {
            setTimeout(() => {
                console.log('🔍 Auto-running UI validation tests...');
                runAllTests();
            }, 1000);
        });
    </script>
</body>
</html>